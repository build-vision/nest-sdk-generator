/**
 * @file Entrypoint of the SDK generator
 */

import * as fs from 'fs'
import * as path from 'path'

import { SdkContent } from '../analyzer'
import { SdkController } from '../analyzer/controller'
import { normalizeExternalFilePath } from '../analyzer/typedeps'
import { Config } from '../config'
import { debug, panic, println } from '../logging'

import { generateSdkModules } from './genmodules'
import { generateSdkTypeFiles } from './gentypes'
import { findPrettierConfig, prettify } from './prettier'
import { defaultSdkInterface } from './sdk-interface'

export default async function generateRTKQueryEndpoints(config: Config, sdkContent: SdkContent): Promise<void> {
  validateSdkContent(sdkContent)

  const prettifyOutput = config.prettify !== false

  if (!prettifyOutput) {
    debug('NOTE: files will not be prettified with Prettier')
  }

  const outputPath = path.resolve(process.cwd(), config.sdkOutputPath)
  const inputPath = path.resolve(process.cwd(), config.apiInputPath)
  const inputRelativePath = path.relative(outputPath, inputPath)

  if (fs.existsSync(outputPath)) {
    if (config.overwriteOldOutputDir === false) {
      panic("Please provide an output directory that doesn't exist yet")
    } else {
      fs.rmSync(outputPath, { recursive: true })
    }
  }

  const outputParentDir = path.dirname(outputPath)

  if (!fs.existsSync(outputParentDir)) {
    panic("Output directory's parent {magentaBright} does not exist.", outputParentDir)
  }

  fs.mkdirSync(outputPath)

  const prettierConfig = prettifyOutput ? findPrettierConfig(config) : {}

  const writeScriptTo = async (parentDir: null | string, file: string, utf8Content: string) => {
    if (file.endsWith('.ts')) {
      utf8Content =
        '/// Auto-generated file (nest-sdk-generator)\n' +
        '/// Please do not edit this file - re-generate the SDK using the generator instead.\n' +
        (config.generateTimestamps !== false ? '/// Generated on: ' + new Date().toUTCString() + '\n' : '') +
        '///\n' +
        utf8Content
    }

    const fullPath = path.resolve(outputPath, parentDir ?? '', file)
    fs.mkdirSync(path.dirname(fullPath), { recursive: true })

    const fileContent = prettifyOutput
      ? await prettify(utf8Content, prettierConfig, file.endsWith('.json') ? 'json' : 'typescript')
      : utf8Content
    fs.writeFileSync(fullPath, fileContent, 'utf8')
  }

  println('> Generating type files...')

  for (const [file, content] of generateSdkTypeFiles(sdkContent.types)) {
    await writeScriptTo('_types', normalizeExternalFilePath(file), content)
  }

  println('> Generating modules...')
  const modules = sdkContent.modules
  for (const [file, content] of generateSdkModules({ modules, inputRelativePath })) {
    await writeScriptTo(null, file, content)
  }

  const sdkInterfacePath = path.resolve(process.cwd(), config.sdkInterfacePath)

  const relativeSdkInterfacePath = path
    .relative(outputPath, sdkInterfacePath)
    .replace(/\\/g, '/')
    .replace(/\.([jt]sx?)$/, '')

  await writeScriptTo(null, 'baseRequest.ts', `export { BaseRequest, type BaseRequestArgs } from "${relativeSdkInterfacePath}"`)

  if (!fs.existsSync(sdkInterfacePath) && config.generateDefaultSdkInterface !== false) {
    println('├─ Generating default SDK interface...')

    fs.writeFileSync(sdkInterfacePath, defaultSdkInterface, 'utf8')
  }
}

export const validateSdkContent = (content: SdkContent): void => {
  const seenMethods = new Map<string, SdkController>()
  const seenRoutes = new Map<string, SdkController>()

  content.modules.forEach((module) => {
    module.forEach((controller) => {
      controller.methods.forEach((method) => {
        if (seenMethods.has(method.name)) {
          const oldController = seenMethods.get(method.name)!
          panic(
            `Duplicate method name found: ${method.name} in ${controller.className} and ${oldController.className}\n
            RTK Query requires globally unique method names.`
          )
        }

        seenMethods.set(method.name, controller)

        if (seenRoutes.has(method.uriPath)) {
          const oldController = seenRoutes.get(method.uriPath)!
          panic(`Duplicate route URI found: ${method.uriPath} in ${controller.className} and ${oldController.className}`)
        }
      })
    })
  })
}
